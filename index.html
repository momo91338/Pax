<!DOCTYPE html><html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Art Editor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }#controls {
  margin-bottom: 20px;
}

#convertBtn {
  padding: 10px 20px;
  background: #4CAF50;
  color: white;
  border: none;
  cursor: pointer;
  margin-top: 10px;
}

.gridWrapper {
  display: grid;
  gap: 20px;
}

.resultBlock {
  border: 1px solid #ccc;
  padding: 10px;
}

.pixelContainer {
  display: grid;
  gap: 1px;
  margin-bottom: 10px;
}

.pixel {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: white;
  width: 10px;
  height: 10px;
  border: 1px solid #000;
}

table {
  border-collapse: collapse;
  width: 100%;
  margin-top: 10px;
}

th, td {
  border: 1px solid #ccc;
  padding: 5px;
  text-align: center;
}

h3 {
  text-align: center;
  margin: 5px 0;
}

  </style>
</head>
<body>
<h1>La mosaïque moderne

</h1>
<p>يفضَّل أن تكون الصورة مربعة، وإذا كنت تستخدم الهاتف، ففعّل وضع الموقع المخصص لأجهزة الكمبيوتر.
</p>
<p>:
Il est préférable que l'image soit carrée. Si vous utilisez un téléphone, activez le mode site pour ordinateur.
</p>
<div id="controls">
  <input type="file" id="imageInput" accept="image/*"><br>
  <img id="imagePreview" style="max-width:300px; display:none;">
  <br>
  <label>عدد الأقسام:</label>
  <select id="sectionCount">
    <option value="1">1</option>
    <option value="4">4</option>
    <option value="8">8</option>
    <option value="16">16</option>
  </select>
  <br>
  <label>عرض الشبكة:</label>
  <input type="number" id="gridWidth" min="1" value="20">
  <label>ارتفاع الشبكة:</label>
  <input type="number" id="gridHeight" min="1" value="20">
  <br><br>
  <label>اختر اللون الثاني:</label>
  <input type="color" id="color2" value="#000000">
  <br>
  <button id="convertBtn" disabled>تحويل الصورة باستخدام تدرج الأبيض واللون الثاني</button>
</div><div id="results"></div><script>
  let originalImage;
  let blendMap = {};
  let blockCounter = 1;
  let hasConverted = false;

  document.getElementById('imageInput').addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      originalImage = new Image();
      originalImage.onload = function () {
        document.getElementById('imagePreview').src = originalImage.src;
        document.getElementById('imagePreview').style.display = 'block';
        document.getElementById('convertBtn').disabled = false;
        hasConverted = false;
      };
      originalImage.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });

  document.getElementById('convertBtn').addEventListener('click', function () {
    if (hasConverted) return;
    hasConverted = true;
    this.disabled = true;

    const gridWidth = parseInt(document.getElementById('gridWidth').value);
    const gridHeight = parseInt(document.getElementById('gridHeight').value);
    const sectionCount = parseInt(document.getElementById('sectionCount').value);

    const white = [255, 255, 255];
    const c2 = hexToRgb(document.getElementById('color2').value);
    const palette = generateGradient(white, c2, 10);

    blendMap = {};
    palette.forEach((color, index) => {
      const hex = rgbToHex(...color);
      const percentWhite = ((9 - index) / 9 * 100).toFixed(0);
      const percentColor = (100 - percentWhite);
      blendMap[hex] = `${percentWhite}% أبيض + ${percentColor}% لون مختار`;
    });

    const sqrt = Math.sqrt(sectionCount);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = originalImage.width;
    canvas.height = originalImage.height;
    ctx.drawImage(originalImage, 0, 0);

    const sectionWidth = canvas.width / sqrt;
    const sectionHeight = canvas.height / sqrt;

    const results = document.getElementById('results');
    results.innerHTML = '';
    blockCounter = 1;

    const gridWrapper = document.createElement('div');
    gridWrapper.className = 'gridWrapper';
    gridWrapper.style.gridTemplateColumns = `repeat(${sqrt}, 1fr)`;

    for (let i = 0; i < sqrt; i++) {
      for (let j = 0; j < sqrt; j++) {
        const x = j * sectionWidth;
        const y = i * sectionHeight;

        const imageData = ctx.getImageData(x, y, sectionWidth, sectionHeight);
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = sectionWidth;
        tempCanvas.height = sectionHeight;
        tempCtx.putImageData(imageData, 0, 0);

        const partImage = new Image();
        partImage.src = tempCanvas.toDataURL();

        partImage.onload = function () {
          const scaledCanvas = document.createElement('canvas');
          const scaledCtx = scaledCanvas.getContext('2d');
          scaledCanvas.width = gridWidth;
          scaledCanvas.height = gridHeight;
          scaledCtx.drawImage(partImage, 0, 0, gridWidth, gridHeight);

          let pixels = [];
          for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
              const data = scaledCtx.getImageData(x, y, 1, 1).data;
              pixels.push([data[0], data[1], data[2]]);
            }
          }

          const mappedPixels = pixels.map((px) => {
            const closest = findClosestColor(px, palette);
            return rgbToHex(...closest);
          });

          renderResult(gridWrapper, gridWidth, mappedPixels);
        };
      }
    }
    results.appendChild(gridWrapper);
  });

  function renderResult(wrapper, gridWidth, pixels) {
    const colorMap = new Map();
    const container = document.createElement('div');
    container.className = 'pixelContainer';
    container.style.gridTemplateColumns = `repeat(${gridWidth}, 10px)`;

    pixels.forEach((hex) => {
      if (!colorMap.has(hex)) {
        colorMap.set(hex, { number: colorMap.size + 1, count: 0 });
      }
      colorMap.get(hex).count++;
      const colorData = colorMap.get(hex);
      const div = document.createElement('div');
      div.className = 'pixel';
      div.style.backgroundColor = hex;
      div.textContent = colorData.number;
      container.appendChild(div);
    });

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    thead.innerHTML = `<tr><th>رقم</th><th>كود اللون</th><th>عدد البكسلات</th><th>الدمج</th></tr>`;
    const tbody = document.createElement('tbody');

    [...colorMap.entries()].forEach(([hex, data]) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${data.number}</td><td>${hex}</td><td>${data.count}</td><td>${blendMap[hex]}</td>`;
      tbody.appendChild(tr);
    });

    const totalColorsRow = document.createElement('tr');
    totalColorsRow.innerHTML = `<td colspan="4"><strong>عدد الألوان في الصورة: ${colorMap.size}</strong></td>`;
    tbody.appendChild(totalColorsRow);

    table.appendChild(thead);
    table.appendChild(tbody);

    const block = document.createElement('div');
    block.className = 'resultBlock';
    const title = document.createElement('h3');
    title.textContent = `صورة رقم ${blockCounter++}`;
    block.appendChild(title);
    block.appendChild(container);
    block.appendChild(table);

    wrapper.appendChild(block);
  }

  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
  }

  function hexToRgb(hex) {
    const bigint = parseInt(hex.replace('#', ''), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
  }

  function generateGradient(c1, c2, steps) {
    const result = [];
    for (let i = 0; i < steps; i++) {
      const ratio = i / (steps - 1);
      const r = Math.round(c1[0] + (c2[0] - c1[0]) * ratio);
      const g = Math.round(c1[1] + (c2[1] - c1[1]) * ratio);
      const b = Math.round(c1[2] + (c2[2] - c1[2]) * ratio);
      result.push([r, g, b]);
    }
    return result;
  }

  function findClosestColor(target, palette) {
    let minDist = Infinity;
    let closest = palette[0];
    for (const color of palette) {
      const dist = Math.sqrt(
        (target[0] - color[0]) ** 2 +
        (target[1] - color[1]) ** 2 +
        (target[2] - color[2]) ** 2
      );
      if (dist < minDist) {
        minDist = dist;
        closest = color;
      }
    }
    return closest;
  }
</script></body>
</html>